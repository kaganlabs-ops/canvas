<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kreuzberg Hacker Den</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: #000;
      font-family: 'Courier New', monospace;
    }
    #canvas { display: block; }

    /* HUD Overlay */
    .hud {
      position: fixed;
      color: #00ffff;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      pointer-events: none;
      z-index: 100;
    }
    .hud-top-left {
      top: 70px;
      left: 20px;
    }

    /* Back Button */
    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 150;
      padding: 8px 16px;
      background: transparent;
      border: 1px solid #33ff00;
      color: #33ff00;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
      text-shadow: 0 0 5px rgba(51, 255, 0, 0.5);
    }
    .back-btn:hover {
      background: #33ff00;
      color: #0a0a0a;
      text-shadow: none;
    }
    .hud-top-right {
      top: 20px;
      right: 20px;
      text-align: right;
    }
    .hud-bottom-left {
      bottom: 20px;
      left: 20px;
    }
    .hud-bottom-right {
      bottom: 20px;
      right: 20px;
      text-align: right;
    }
    .hud-line {
      margin: 4px 0;
      animation: glitch 3s infinite;
    }
    @keyframes glitch {
      0%, 90%, 100% { opacity: 1; transform: translateX(0); }
      92% { opacity: 0.8; transform: translateX(-2px); }
      94% { opacity: 1; transform: translateX(2px); }
    }

    /* Terminal Overlay */
    #terminal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    #terminal-overlay.active { display: flex; }
    #terminal {
      width: 80%;
      max-width: 800px;
      height: 60%;
      background: #0a0a0a;
      border: 1px solid #00ffff;
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.3), inset 0 0 30px rgba(0, 255, 255, 0.1);
      padding: 20px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #00ff00;
    }
    #terminal-output {
      white-space: pre-wrap;
      margin-bottom: 10px;
    }
    #terminal-input-line {
      display: flex;
      align-items: center;
    }
    #terminal-prompt {
      color: #ff00ff;
      margin-right: 8px;
    }
    #terminal-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #00ff00;
      font-family: inherit;
      font-size: inherit;
      outline: none;
      caret-color: #00ffff;
    }
    #terminal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      color: #ff0066;
      font-size: 24px;
      cursor: pointer;
      text-shadow: 0 0 10px #ff0066;
    }

    /* Scanlines */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 50;
      background: repeating-linear-gradient(
        0deg,
        rgba(0, 0, 0, 0.1) 0px,
        rgba(0, 0, 0, 0.1) 1px,
        transparent 1px,
        transparent 2px
      );
      opacity: 0.3;
    }

    /* Loading */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: #00ffff;
      font-family: 'Courier New', monospace;
    }
    #loading.hidden { display: none; }
    .loading-text {
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 3px;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loading-text">Initializing Kreuzberg Node...</div>
  </div>

  <!-- Back Button -->
  <button class="back-btn" onclick="window.location.href='/world'">[ &lt; BACK ]</button>

  <canvas id="canvas"></canvas>

  <div class="scanlines"></div>

  <div class="hud hud-top-left">
    <div class="hud-line">FPS: <span id="fps">60</span></div>
    <div class="hud-line">MODE: OBSERVATION</div>
  </div>

  <div class="hud hud-top-right">
    <div class="hud-line">KREUZBERG NET ACCESS: <span style="color: #00ff00;">ONLINE</span></div>
    <div class="hud-line">RAIN: <span id="rain-intensity">0.85</span></div>
  </div>

  <div class="hud hud-bottom-left">
    <div class="hud-line">NODE 47 // BERLIN DARKNET</div>
    <div class="hud-line" id="time-display">00:00:00</div>
  </div>

  <div class="hud hud-bottom-right">
    <div class="hud-line">CLICK MONITOR TO HACK</div>
    <div class="hud-line">DRAG TO LOOK AROUND</div>
  </div>

  <div id="terminal-overlay">
    <div id="terminal-close">[X] ESC</div>
    <div id="terminal">
      <div id="terminal-output"></div>
      <div id="terminal-input-line">
        <span id="terminal-prompt">root@kreuzberg:~$</span>
        <input type="text" id="terminal-input" autofocus>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    // Chromatic Aberration Shader
    const ChromaticAberrationShader = {
      uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        varying vec2 vUv;
        void main() {
          vec2 offset = amount * vec2(1.0, 0.0);
          vec4 cr = texture2D(tDiffuse, vUv + offset);
          vec4 cg = texture2D(tDiffuse, vUv);
          vec4 cb = texture2D(tDiffuse, vUv - offset);
          gl_FragColor = vec4(cr.r, cg.g, cb.b, 1.0);
        }
      `
    };

    // Vignette Shader
    const VignetteShader = {
      uniforms: {
        tDiffuse: { value: null },
        darkness: { value: 0.6 },
        offset: { value: 1.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float darkness;
        uniform float offset;
        varying vec2 vUv;
        void main() {
          vec4 texel = texture2D(tDiffuse, vUv);
          vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
          float vignette = 1.0 - dot(uv, uv);
          gl_FragColor = vec4(texel.rgb * mix(1.0 - darkness, 1.0, vignette), texel.a);
        }
      `
    };

    // Scene Setup
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.03);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(4, 2.5, 6);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;

    // Post Processing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.8, 0.4, 0.85
    );
    composer.addPass(bloomPass);

    const chromaticPass = new ShaderPass(ChromaticAberrationShader);
    composer.addPass(chromaticPass);

    const vignettePass = new ShaderPass(VignetteShader);
    composer.addPass(vignettePass);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 1.5, 0);
    controls.minDistance = 2;
    controls.maxDistance = 12;
    controls.maxPolarAngle = Math.PI * 0.85;
    controls.minPolarAngle = Math.PI * 0.1;

    // Materials
    const neonCyan = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 2
    });
    const neonMagenta = new THREE.MeshStandardMaterial({
      color: 0xff00ff,
      emissive: 0xff00ff,
      emissiveIntensity: 2
    });
    const neonBlue = new THREE.MeshStandardMaterial({
      color: 0x0066ff,
      emissive: 0x0066ff,
      emissiveIntensity: 1.5
    });
    const darkMetal = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      roughness: 0.7,
      metalness: 0.8
    });
    const concrete = new THREE.MeshStandardMaterial({
      color: 0x2a2a3a,
      roughness: 0.9,
      metalness: 0.1
    });
    const screenMaterial = new THREE.MeshStandardMaterial({
      color: 0x001122,
      emissive: 0x003366,
      emissiveIntensity: 0.5
    });

    // Room Structure
    // Floor
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 8),
      concrete
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Walls
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: 0x151525,
      roughness: 0.8
    });

    // Back wall
    const backWall = new THREE.Mesh(new THREE.PlaneGeometry(10, 4), wallMaterial);
    backWall.position.set(0, 2, -4);
    scene.add(backWall);

    // Left wall
    const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(8, 4), wallMaterial);
    leftWall.position.set(-5, 2, 0);
    leftWall.rotation.y = Math.PI / 2;
    scene.add(leftWall);

    // Right wall (window)
    const windowFrame = new THREE.Group();
    const windowGlass = new THREE.Mesh(
      new THREE.PlaneGeometry(7, 3.5),
      new THREE.MeshStandardMaterial({
        color: 0x0a1020,
        transparent: true,
        opacity: 0.3,
        roughness: 0.1,
        metalness: 0.9
      })
    );
    windowGlass.position.set(5, 2, 0);
    windowGlass.rotation.y = -Math.PI / 2;
    windowGlass.name = 'window';
    scene.add(windowGlass);

    // Ceiling with exposed pipes
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(10, 8), wallMaterial);
    ceiling.position.set(0, 4, 0);
    ceiling.rotation.x = Math.PI / 2;
    scene.add(ceiling);

    // Pipes on ceiling
    for (let i = 0; i < 5; i++) {
      const pipe = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 10),
        darkMetal
      );
      pipe.rotation.z = Math.PI / 2;
      pipe.position.set(0, 3.8, -3 + i * 1.5);
      scene.add(pipe);
    }

    // L-Shaped Desk
    const deskGroup = new THREE.Group();
    const deskMaterial = new THREE.MeshStandardMaterial({
      color: 0x1a1a2e,
      roughness: 0.4,
      metalness: 0.6
    });

    // Main desk part
    const deskTop1 = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 1.2), deskMaterial);
    deskTop1.position.set(-1.5, 0.8, -3);
    deskTop1.castShadow = true;
    deskGroup.add(deskTop1);

    // Side desk part
    const deskTop2 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 2.5), deskMaterial);
    deskTop2.position.set(-4, 0.8, -1.5);
    deskTop2.castShadow = true;
    deskGroup.add(deskTop2);

    // Desk legs
    const legGeo = new THREE.BoxGeometry(0.1, 0.8, 0.1);
    const legPositions = [
      [-3.4, 0.4, -3.5], [0.4, 0.4, -3.5], [-3.4, 0.4, -2.5],
      [-4.5, 0.4, -2.6], [-4.5, 0.4, -0.4]
    ];
    legPositions.forEach(pos => {
      const leg = new THREE.Mesh(legGeo, darkMetal);
      leg.position.set(...pos);
      deskGroup.add(leg);
    });

    scene.add(deskGroup);

    // Monitors (clickable)
    const monitors = [];
    const monitorGroup = new THREE.Group();

    const createMonitor = (width, height, x, y, z, rotY = 0) => {
      const group = new THREE.Group();

      // Frame
      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(width + 0.1, height + 0.1, 0.05),
        darkMetal
      );
      group.add(frame);

      // Screen
      const screen = new THREE.Mesh(
        new THREE.PlaneGeometry(width, height),
        screenMaterial.clone()
      );
      screen.position.z = 0.03;
      screen.name = 'monitor-screen';
      screen.userData.isMonitor = true;
      group.add(screen);

      group.position.set(x, y, z);
      group.rotation.y = rotY;

      monitors.push({ group, screen, baseEmissive: 0.5 });
      return group;
    };

    // Main monitors on desk
    monitorGroup.add(createMonitor(0.8, 0.5, -2.5, 1.3, -3.4));
    monitorGroup.add(createMonitor(0.7, 0.45, -1.6, 1.35, -3.4));
    monitorGroup.add(createMonitor(0.6, 0.4, -0.8, 1.25, -3.4));
    monitorGroup.add(createMonitor(0.75, 0.5, -0.2, 1.5, -3.4)); // Stacked
    monitorGroup.add(createMonitor(0.5, 0.35, -4.4, 1.2, -2, Math.PI / 2));
    monitorGroup.add(createMonitor(0.6, 0.4, -4.4, 1.2, -1, Math.PI / 2));

    scene.add(monitorGroup);

    // Holographic Screens (floating)
    const holoScreens = [];
    const holoMaterial = new THREE.MeshStandardMaterial({
      color: 0x00ffff,
      emissive: 0x00ffff,
      emissiveIntensity: 0.3,
      transparent: true,
      opacity: 0.4,
      side: THREE.DoubleSide
    });

    const createHoloScreen = (x, y, z) => {
      const holo = new THREE.Mesh(
        new THREE.PlaneGeometry(0.6, 0.4),
        holoMaterial.clone()
      );
      holo.position.set(x, y, z);
      holo.userData.isHolo = true;
      holo.userData.originalPos = new THREE.Vector3(x, y, z);
      holoScreens.push(holo);
      scene.add(holo);
      return holo;
    };

    createHoloScreen(-2, 2.2, -3);
    createHoloScreen(-1.2, 2.4, -2.8);
    createHoloScreen(-0.5, 2.1, -3.1);

    // Couch
    const couchGroup = new THREE.Group();
    const couchMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a1a1a,
      roughness: 0.9
    });

    const couchBase = new THREE.Mesh(new THREE.BoxGeometry(2, 0.4, 0.8), couchMaterial);
    couchBase.position.set(3, 0.3, -2);
    couchGroup.add(couchBase);

    const couchBack = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 0.15), couchMaterial);
    couchBack.position.set(3, 0.7, -2.35);
    couchGroup.add(couchBack);

    scene.add(couchGroup);

    // Pizza boxes and cans (clutter)
    const pizzaBox = new THREE.Mesh(
      new THREE.BoxGeometry(0.4, 0.05, 0.4),
      new THREE.MeshStandardMaterial({ color: 0x8B4513 })
    );
    pizzaBox.position.set(3.3, 0.55, -1.8);
    scene.add(pizzaBox);

    // Energy drink cans
    for (let i = 0; i < 3; i++) {
      const can = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.12),
        new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.3 })
      );
      can.position.set(2.5 + i * 0.15, 0.56, -1.9);
      scene.add(can);
    }

    // LED strips on ceiling
    const ledStrip = new THREE.Mesh(
      new THREE.BoxGeometry(8, 0.02, 0.05),
      neonMagenta
    );
    ledStrip.position.set(0, 3.9, -2);
    scene.add(ledStrip);

    const ledStrip2 = new THREE.Mesh(
      new THREE.BoxGeometry(8, 0.02, 0.05),
      neonCyan
    );
    ledStrip2.position.set(0, 3.9, 1);
    scene.add(ledStrip2);

    // Cables (procedural)
    const cableCount = 15;
    for (let i = 0; i < cableCount; i++) {
      const points = [];
      const startX = -3.5 + Math.random() * 2;
      const startZ = -3.5 + Math.random() * 0.5;

      for (let j = 0; j < 5; j++) {
        points.push(new THREE.Vector3(
          startX + Math.random() * 0.5,
          0.85 - j * 0.15 - Math.random() * 0.1,
          startZ + Math.random() * 0.3
        ));
      }

      const curve = new THREE.CatmullRomCurve3(points);
      const tubeGeo = new THREE.TubeGeometry(curve, 10, 0.01, 8, false);
      const cable = new THREE.Mesh(tubeGeo, new THREE.MeshStandardMaterial({
        color: [0x111111, 0x1a1a1a, 0x0a0a0a][Math.floor(Math.random() * 3)]
      }));
      scene.add(cable);
    }

    // Server rack
    const serverRack = new THREE.Group();
    const rackFrame = new THREE.Mesh(
      new THREE.BoxGeometry(0.6, 1.8, 0.5),
      darkMetal
    );
    rackFrame.position.set(-4.5, 0.9, 2);
    serverRack.add(rackFrame);

    // Server lights
    for (let i = 0; i < 8; i++) {
      const light = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.02),
        i % 3 === 0 ? neonCyan : (i % 2 === 0 ? new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 }) : neonMagenta)
      );
      light.position.set(-4.22, 0.3 + i * 0.2, 2.1);
      serverRack.add(light);
    }
    scene.add(serverRack);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x101020, 0.3);
    scene.add(ambientLight);

    // Neon lights
    const cyanLight = new THREE.PointLight(0x00ffff, 2, 8);
    cyanLight.position.set(-2, 2, -3);
    scene.add(cyanLight);

    const magentaLight = new THREE.PointLight(0xff00ff, 1.5, 6);
    magentaLight.position.set(-4, 2, 0);
    scene.add(magentaLight);

    const blueLight = new THREE.PointLight(0x0066ff, 1, 5);
    blueLight.position.set(3, 2, -2);
    scene.add(blueLight);

    // Window glow (city lights)
    const windowLight = new THREE.RectAreaLight(0x0066ff, 3, 7, 3.5);
    windowLight.position.set(4.9, 2, 0);
    windowLight.rotation.y = -Math.PI / 2;
    scene.add(windowLight);

    // Rain Particle System
    const rainCount = 600;
    const rainGeometry = new THREE.BufferGeometry();
    const rainPositions = new Float32Array(rainCount * 3);
    const rainVelocities = new Float32Array(rainCount);

    for (let i = 0; i < rainCount; i++) {
      rainPositions[i * 3] = 4.9;
      rainPositions[i * 3 + 1] = Math.random() * 4;
      rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 8;
      rainVelocities[i] = 0.02 + Math.random() * 0.03;
    }

    rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));

    const rainMaterial = new THREE.PointsMaterial({
      color: 0x6699ff,
      size: 0.03,
      transparent: true,
      opacity: 0.6,
      blending: THREE.AdditiveBlending
    });

    const rain = new THREE.Points(rainGeometry, rainMaterial);
    scene.add(rain);

    // Dust Particles
    const dustCount = 150;
    const dustGeometry = new THREE.BufferGeometry();
    const dustPositions = new Float32Array(dustCount * 3);

    for (let i = 0; i < dustCount; i++) {
      dustPositions[i * 3] = (Math.random() - 0.5) * 10;
      dustPositions[i * 3 + 1] = Math.random() * 4;
      dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 8;
    }

    dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

    const dustMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.02,
      transparent: true,
      opacity: 0.3,
      blending: THREE.AdditiveBlending
    });

    const dust = new THREE.Points(dustGeometry, dustMaterial);
    scene.add(dust);

    // Raycaster for interactions
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMonitor = null;

    // Terminal State
    const terminalOverlay = document.getElementById('terminal-overlay');
    const terminalOutput = document.getElementById('terminal-output');
    const terminalInput = document.getElementById('terminal-input');
    let terminalActive = false;

    const bootSequence = [
      'KREUZBERG DARKNET TERMINAL v3.7.1',
      '================================',
      '',
      'Establishing secure connection...',
      'Routing through TOR nodes: Berlin > Prague > Seoul',
      'Connection encrypted: AES-256-GCM',
      '',
      'Welcome to Node 47.',
      'Type "help" for available commands.',
      ''
    ];

    const commands = {
      help: () => [
        'Available commands:',
        '  scan     - Scan local network',
        '  status   - System status',
        '  decrypt  - Decrypt intercepted data',
        '  exit     - Close terminal',
        '  clear    - Clear screen'
      ],
      scan: () => [
        'Scanning Kreuzberg subnet...',
        '  192.168.47.1   [ROUTER] Mesh Node Alpha',
        '  192.168.47.23  [IOT] Smart Fridge (vulnerable)',
        '  192.168.47.45  [CAM] Street Camera #7',
        '  192.168.47.89  [DRONE] Delivery Unit DHL-7X',
        '  192.168.47.102 [???] Unknown Device',
        'Scan complete. 5 devices found.'
      ],
      status: () => [
        'SYSTEM STATUS:',
        `  Uptime: ${Math.floor(performance.now() / 1000)}s`,
        '  CPU: 47% (mining paused)',
        '  RAM: 12.4GB / 32GB',
        '  Darknet Peers: 1,247',
        '  BTC Wallet: 0.00847 BTC',
        '  Current bounty: 2500 EUR'
      ],
      decrypt: () => [
        'Decrypting latest intercept...',
        '...',
        'SOURCE: BVG Transit Authority',
        'CONTENT: U-Bahn maintenance schedule',
        'VALUE: Low priority',
        '',
        'Stored to /data/intercepts/'
      ],
      clear: () => {
        terminalOutput.textContent = '';
        return [];
      },
      exit: () => {
        closeTerminal();
        return [];
      }
    };

    function openTerminal() {
      terminalActive = true;
      terminalOverlay.classList.add('active');
      terminalOutput.textContent = bootSequence.join('\n') + '\n';
      terminalInput.value = '';
      terminalInput.focus();
      controls.enabled = false;
    }

    function closeTerminal() {
      terminalActive = false;
      terminalOverlay.classList.remove('active');
      controls.enabled = true;
    }

    terminalInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const cmd = terminalInput.value.trim().toLowerCase();
        terminalOutput.textContent += `root@kreuzberg:~$ ${cmd}\n`;

        if (commands[cmd]) {
          const output = commands[cmd]();
          if (output.length) {
            terminalOutput.textContent += output.join('\n') + '\n\n';
          }
        } else if (cmd) {
          terminalOutput.textContent += `Command not found: ${cmd}\n\n`;
        }

        terminalInput.value = '';
        terminalOutput.scrollTop = terminalOutput.scrollHeight;
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && terminalActive) {
        closeTerminal();
      }
    });

    document.getElementById('terminal-close').addEventListener('click', closeTerminal);

    // Mouse Events
    canvas.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    });

    canvas.addEventListener('click', () => {
      if (hoveredMonitor) {
        openTerminal();
      }
    });

    // Window interaction - thunder effect
    let lastThunder = 0;
    canvas.addEventListener('click', (e) => {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(windowGlass);

      if (intersects.length > 0 && Date.now() - lastThunder > 3000) {
        lastThunder = Date.now();
        // Thunder flash
        const originalExposure = renderer.toneMappingExposure;
        renderer.toneMappingExposure = 3;
        setTimeout(() => {
          renderer.toneMappingExposure = originalExposure;
        }, 100);
        // Increase rain temporarily
        rainIntensity = 1.5;
        setTimeout(() => { rainIntensity = 0.85; }, 2000);
      }
    });

    // Animation variables
    let rainIntensity = 0.85;
    let time = 0;
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 60;

    // Random events
    let nextEvent = Date.now() + 30000 + Math.random() * 60000;

    function triggerRandomEvent() {
      const eventType = Math.random();

      if (eventType < 0.5) {
        // Power flicker
        const flickers = 3;
        let flickerCount = 0;
        const flickerInterval = setInterval(() => {
          renderer.toneMappingExposure = flickerCount % 2 === 0 ? 0.3 : 0.8;
          flickerCount++;
          if (flickerCount >= flickers * 2) {
            clearInterval(flickerInterval);
            renderer.toneMappingExposure = 0.8;
          }
        }, 100);
      }

      nextEvent = Date.now() + 30000 + Math.random() * 60000;
    }

    // Update time display
    function updateTimeDisplay() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const mins = String(now.getMinutes()).padStart(2, '0');
      const secs = String(now.getSeconds()).padStart(2, '0');
      document.getElementById('time-display').textContent = `${hours}:${mins}:${secs}`;
    }

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);

      time += 0.016;
      frameCount++;

      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        document.getElementById('fps').textContent = fps;
        updateTimeDisplay();
      }

      // Update rain
      const rainPos = rain.geometry.attributes.position.array;
      for (let i = 0; i < rainCount; i++) {
        rainPos[i * 3 + 1] -= rainVelocities[i] * rainIntensity;
        if (rainPos[i * 3 + 1] < 0) {
          rainPos[i * 3 + 1] = 4;
        }
        // Slight wind sway
        rainPos[i * 3 + 2] += Math.sin(time + i) * 0.001;
      }
      rain.geometry.attributes.position.needsUpdate = true;
      document.getElementById('rain-intensity').textContent = rainIntensity.toFixed(2);

      // Update dust
      const dustPos = dust.geometry.attributes.position.array;
      for (let i = 0; i < dustCount; i++) {
        dustPos[i * 3 + 1] += Math.sin(time * 0.5 + i) * 0.001;
        dustPos[i * 3] += Math.cos(time * 0.3 + i) * 0.001;
      }
      dust.geometry.attributes.position.needsUpdate = true;

      // Animate holo screens
      holoScreens.forEach((holo, i) => {
        holo.position.y = holo.userData.originalPos.y + Math.sin(time * 0.5 + i) * 0.05;
        holo.rotation.y = Math.sin(time * 0.2 + i) * 0.1;
      });

      // LED strip pulse
      ledStrip.material.emissiveIntensity = 1.5 + Math.sin(time * 2) * 0.5;
      ledStrip2.material.emissiveIntensity = 1.5 + Math.sin(time * 2 + Math.PI) * 0.5;

      // Monitor hover check
      raycaster.setFromCamera(mouse, camera);
      const monitorScreens = monitors.map(m => m.screen);
      const intersects = raycaster.intersectObjects(monitorScreens);

      // Reset all monitors
      monitors.forEach(m => {
        m.screen.material.emissiveIntensity = m.baseEmissive;
      });

      if (intersects.length > 0 && !terminalActive) {
        const hitScreen = intersects[0].object;
        const monitor = monitors.find(m => m.screen === hitScreen);
        if (monitor) {
          monitor.screen.material.emissiveIntensity = 1.5;
          hoveredMonitor = monitor;
          canvas.style.cursor = 'pointer';
        }
      } else {
        hoveredMonitor = null;
        canvas.style.cursor = 'default';
      }

      // Random events
      if (Date.now() > nextEvent) {
        triggerRandomEvent();
      }

      // Subtle camera breathing
      camera.position.y += Math.sin(time * 0.5) * 0.0005;

      controls.update();
      composer.render();
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

    // Hide loading screen
    setTimeout(() => {
      document.getElementById('loading').classList.add('hidden');
    }, 1500);

    // Start animation
    animate();

    // Audio (subtle ambient)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function createAmbientDrone() {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.type = 'sine';
      oscillator.frequency.value = 55;
      gainNode.gain.value = 0.02;

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      oscillator.start();

      // Slowly modulate
      setInterval(() => {
        oscillator.frequency.value = 50 + Math.random() * 10;
      }, 3000);
    }

    // Start audio on first interaction
    let audioStarted = false;
    document.addEventListener('click', () => {
      if (!audioStarted) {
        audioStarted = true;
        audioContext.resume().then(() => {
          createAmbientDrone();
        });
      }
    }, { once: true });
  </script>
</body>
</html>
